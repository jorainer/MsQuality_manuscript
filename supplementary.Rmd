---
title: "MsQuality: "
subtitle: "Supplementary information"
author:
    - Thomas Naake,^[European Molecular Biology Laboratory, Meyerhofstrasse 1, 69117 Heidelberg, Germany]
    - Johannes Rainer^[]
    - Wolfgang Huber^[European Molecular Biology Laboratory, Meyerhofstrasse 1, 69117 Heidelberg, Germany]
package: MsQuality

bibliography: document.bib
fontsize: 12pt
output:
  pdf_document:
    includes:
      in_header: "preamble.tex"
    extra_dependencies: ["natbib", "float", "lscape", "subfig", "graphicx"]
    fig_caption: true
    keep_tex: true
    citation_package: natbib
    toc_depth: 3
    number_sections: true
---

The Supplementary Information showcases the functionality of the 
`MsQuality` package by presenting an exemplary analysis workflow. While the
`MsQuality` package entails an interactive shiny application, including
also interactive plots based on the `plotly` framework, static
plots are presented here.

The analysis here focuses on the data sets of @Cherkaoui2022 and @Amidan2014.

The data set of @Cherkaoui is a  mass spectrometry
metabolomics data set of 180 cancer cell lines obtained by flow injection 
analysis (TOF, negative ionization mode). The data set contains in total 
1394 samples.

The data set of @Amidan2014 consists of 3400 LC-MS samples of the same 
QC sample (whole cell lysate of *Shewanella oneidensis*). The QC samples
were run on Exactive, LTQ IonTrap, LTQ Orbitrap, and Velos Orbitrap instruments.

The RAW files were downloaded from the indicated FTP repositories and converted
into `.mzML` files using MSConvertGUI (64-bit, v3.0.22015-aadd392) with setting
`peakPicking` to `vendor msLevel=1-`.


```{r style, echo = FALSE, results = 'asis'}
BiocStyle::markdown()
```

```{r env, include=FALSE, echo=FALSE, cache=FALSE}
library("knitr")
knitr::opts_chunk$set(stop_on_error = 1L, fig.pos = "ht")
suppressPackageStartupMessages(library("Spectra"))
suppressPackageStartupMessages(library("MsQuality"))
suppressPackageStartupMessages(library("peakRAM"))
suppressPackageStartupMessages(library("microbenchmark"))
knitr::opts_knit$set(root.dir = "~/Publications/Bioinformatics_MsQuality/")
```

# Preparation of the environment

Load the `Spectra`, `MsQuality`, `peakRAM`, and `microbenchmark` package 
before starting the analysis. 

```{r load_package, echo = TRUE, eval = TRUE}
library("Spectra")
library("MsQuality")
library("ggplot2")
library("tidyr")
library("peakRAM")
library("microbenchmark")
```

\newpage

# Cherkaoui et al. (2022): A functional analysis of 180 cancer cell lines reveals conserved intrinsic metabolic programs

The data set was downloaded from the PRIDE database (accession number PXD006512, 
available at www.ebi.ac.uk/pride/archive) via
ftp://ftp.pride.ebi.ac.uk/pride/data/archive/2019/05/PXD006512. 


## Prepare the mzML files

In order to read the `mzML` files into `R`, the `mzML` files have to be
modified. This is needed in order to have `mzR`-compatible `mzML` files, 
since `mzR` cannot read some of the entries and references in the `mzML` files.

To prepare `R`-readable `mzML` files, we peform the following steps for each 
`mzML` file in the directory:
- replace the space in the file name by "_",
- within the `mzML` file, replace the line beginning with
  `<run defaultInstrumentConfigurationRef=` by `<run`,
- within the mzML file, delete the lines that are between (and including) the 
  lines beginning with `<scanWindowList` and `</scanWindowList`,
- remove the old `mzML` file.

These steps can be conducted via the following `bash` script.

```{bash eval=FALSE, echo=TRUE}
ls *.mzML | while read mzml_i
    do
        new_name="${mzml_i// /_}"
        cp "$mzml_i" "$new_name"
        sed 's/<run defaultInstrumentConfigurationRef=.*/<run/g' "$mzml_i" |
        sed '/^<scanWindowList/,/^<\/scanWindowList/d' > $new_name
        rm "$mzml_i"
    done
```


In the following analysis a `Spectra` object is created. The operations
are performed in a high-performance clustering environment

```{r echo = FALSE}
setwd("~/GitHub/MsQuality_manuscript/")
```

```{r create_spectra_Cherkaoui, eval = FALSE, echo = TRUE, cache=TRUE}
## read the file with protein intensities
.path <- "/scratch/naake/Cherkaoui2022/"
fls <- dir(.path, full.names = TRUE, pattern = "mzML")

## create the Spectra object
sps <- Spectra(fls, backend = MsBackendMzR())
```

```{r echo = FALSE, eval = FALSE}
## save the Spectra object as RDS file
saveRDS(sps, file = "Cherkaoui2022/Cherkaoui2022_sps.RDS")
```

## Calculate the metrics via `MsQuality`
```{r eval = FALSE}
.metrics <- c("numberSpectra", "areaUnderTic", "mzAcquisitionRange")

.metrics_sps <- MsQuality::calculateMetricsFromSpectra(spectra = sps, 
    metrics = .metrics)
saveRDS(.metrics_sps, file = "Cherkaoui2022/Cherkaoui2022_metrics_sps.RDS")
```

```{r eval = TRUE, echo = FALSE}
.metrics_sps <- readRDS("Cherkaoui2022/Cherkaoui2022_metrics_sps.RDS")
```

## Visualization
```{r}
.metrics_sps <- .metrics_sps |>
    as.data.frame() |>
    tibble::rownames_to_column(var = "rowname") |>
    tibble::as_tibble() |>
    tidyr::pivot_longer(cols = 2:(ncol(.metrics_sps) + 1))

## PrimaryAnalysis downloaded from 
## https://www.research-collection.ethz.ch/handle/20.500.11850/511784
.samples <- openxlsx::read.xlsx("Cherkaoui2022/PrimaryAnalysis/metabolomics_180CCL.xlsx",
    sheet = "injections")

## truncate the dataOrigin
.metrics_sps[["rowname"]] <- .metrics_sps[["rowname"]] |>
    strsplit(split = "Cherkaoui2022/") |>
    lapply(FUN = function(names_i) names_i[[2]]) |> 
    unlist() |>
    stringr::str_remove(pattern = ".mzML")

## add information if the samples was analysed (information stored in 
## .samples)
.metrics_sps <- .metrics_sps |> 
    dplyr::mutate(dsCode = sapply(
        strsplit(.metrics_sps$rowname, split = "_Batch"), "[", 1)) |>
    dplyr::mutate(analysed = ifelse(dsCode %in% .samples[["dsCode"]], "yes", "no"))

subset(.metrics_sps, 
    name %in% c("areaUnderTic", "mzAcquisitionRange.min", "mzAcquisitionRange.max")) |>
    ggplot() +
        geom_violin(aes(x = analysed, y = value, col = analysed)) +
        geom_jitter(aes(x = analysed, y = value, col = analysed)) +
        facet_wrap(~ name, scales = "free") +
        theme_classic()
```

## Calculate Peak RAM Used

```{r, eval = FALSE, echo = TRUE}
.path <- "/scratch/naake/Cherkaoui2022"
fls <- dir(.path, full.names = TRUE, pattern = "mzML")
.metrics <- c("numberSpectra", "areaUnderTic", "mzAcquisitionRange")
df_ram <- peakRAM(
    function() {
		bplapply(fls, function(fls_i) {
			calculateMetricsFromSpectra(spectra = sps[sps$dataOrigin == fls_i, ], 
				metrics = .metrics)}, BPPARAM = MulticoreParam(workers = 1))
	},
    function() {
		bplapply(fls, function(fls_i) {
			calculateMetricsFromSpectra(spectra = sps[sps$dataOrigin == fls_i, ], 
				metrics = .metrics)}, BPPARAM = MulticoreParam(workers = 2))
	},
    function() {
		bplapply(fls, function(fls_i) {
			calculateMetricsFromSpectra(spectra = sps[sps$dataOrigin == fls_i, ], 
				metrics = .metrics)}, BPPARAM = MulticoreParam(workers = 4))
	},
    function() {
		bplapply(fls, function(fls_i) {
			calculateMetricsFromSpectra(spectra = sps[sps$dataOrigin == fls_i, ], 
				metrics = .metrics)}, BPPARAM = MulticoreParam(workers = 8))
	},
    function() {
		bplapply(fls, function(fls_i) {
			calculateMetricsFromSpectra(spectra = sps[sps$dataOrigin == fls_i, ], 
				metrics = .metrics)}, BPPARAM = MulticoreParam(workers = 16))
	}
)
```


```{r, eval = FALSE, echo = FALSE}
## save the data.frame as RDS object
saveRDS(df_ram, file = "Cherkaoui2022/Cherkaoui2022_df_ram.RDS")
```

```{r eval = TRUE, echo = FALSE}
df_ram <- readRDS("Cherkaoui2022/Cherkaoui2022_df_ram.RDS")
```

```{r}
df_ram[["Function_Call"]] <- c(1, 2, 4, 8, 16)

df_ram <- df_ram |> 
    pivot_longer(cols = 2:ncol(df_ram), names_to = "parameter") |>
    mutate(parameter = case_when(
        parameter == "Elapsed_Time_sec" ~ "elapsed time (sec)",
        parameter == "Total_RAM_Used_MiB" ~ "used total RAM",
        parameter == "Peak_RAM_Used_MiB" ~ "used peak RAM"))

## visualize the elapsed time per amount of used workers
df_ram |>
    filter(parameter != "elapsed time (sec)") |>
    ggplot() +
        geom_point(aes(x = Function_Call, y = value), size = 3) +
        xlab("number of workers") + ylab("MiB") +
        scale_x_continuous(breaks = df_ram[["Function_Call"]]) +
        facet_wrap(~ parameter, scales = "free_y") +
        theme_bw() +
        theme(axis.title = element_text(size = 16), 
            axis.text = element_text(size = 14),
            panel.grid = element_blank())
```


```{r echo = TRUE, eval = FALSE}
library("microbenchmark")
.path <- "/scratch/naake/Cherkaoui2022"
fls <- dir(.path, full.names = TRUE, pattern = "mzML")
.metrics <- c("numberSpectra", "areaUnderTic", "mzAcquisitionRange")
df_mb <- microbenchmark(
    workers_1 = bplapply(fls, function(fls_i) {
		calculateMetricsFromSpectra(spectra = sps[sps$dataOrigin == fls_i, ], 
			metrics = .metrics)}, BPPARAM = MulticoreParam(workers = 1)),
    workers_2 = bplapply(fls, function(fls_i) {
		calculateMetricsFromSpectra(spectra = sps[sps$dataOrigin == fls_i, ], 
			metrics = .metrics)}, BPPARAM = MulticoreParam(workers = 2)),
    workers_4 = bplapply(fls, function(fls_i) {
		calculateMetricsFromSpectra(spectra = sps[sps$dataOrigin == fls_i, ], 
			metrics = .metrics)}, BPPARAM = MulticoreParam(workers = 4)),
    workers_8 = bplapply(fls, function(fls_i) {
		calculateMetricsFromSpectra(spectra = sps[sps$dataOrigin == fls_i, ], 
			metrics = .metrics)}, BPPARAM = MulticoreParam(workers = 8)),
    workers_16 = bplapply(fls, function(fls_i) {
		calculateMetricsFromSpectra(spectra = sps[sps$dataOrigin == fls_i, ], 
			metrics = .metrics)}, BPPARAM = MulticoreParam(workers = 16)), 
	times = 110L, control = list(warmup = 10), check = "equal"
)
```

```{r, eval = FALSE, echo = FALSE}
## save the data.frame
saveRDS(df_mb, file = "Cherkaoui2022/Cherkaoui2022_df_mb.RDS")
```

```{r eval = TRUE, echo = FALSE}
df_mb <- readRDS(file = "Cherkaoui2022/Cherkaoui2022_df_mb.RDS")
```

```{r echo = TRUE, eval = TRUE}
## convert from nano seconds to seconds
df_mb[["time"]] <- df_mb[["time"]] / 10e9
df_mb <- df_mb |>
    as.data.frame() |>
    mutate(expr = case_when(expr == "workers_1" ~ 1,
        expr == "workers_2" ~ 2, expr == "workers_4" ~ 4,
        expr == "workers_8" ~ 8, expr == "workers_16" ~ 16))

## visualize the elapsed time per amount of used workers
ggplot(df_mb) +
    geom_jitter(aes(x = expr, y = time, col = as.factor(expr)), alpha = 0.2) +
    geom_violin(aes(x = expr, y = time, group = expr, fill = NA), fill = alpha("white", 0)) +
    xlab("number of workers") + ylab("elapsed time (sec)") +
    ##scale_y_continuous(trans = "log2",
    ##    breaks = trans_breaks("log2", function(x) 2^x),
    ##    labels = trans_format("log2", math_format(2^.x)),
    ##    limits = c(3, 100)) +
    guides(color = guide_legend(override.aes = list(alpha = 1))) +
    theme_classic() +
    theme(axis.title = element_text(size = 16), 
            axis.text = element_text(size = 14))
```


# Amidan et al. (2014): Signatures for mass spectrometry data quality


The datasets were downloaded from 

- ftp://ftp.pride.ebi.ac.uk/pride/data/archive/2013/10/PXD000320
  (`1_of_5`),
- ftp://ftp.pride.ebi.ac.uk/pride/data/archive/2013/10/PXD000321
  (`2_of_5`),
- ftp://ftp.pride.ebi.ac.uk/pride/data/archive/2013/10/PXD000322
  (`3_of_5`),
- ftp://ftp.pride.ebi.ac.uk/pride/data/archive/2013/10/PXD000323
  (`4_of_5`),
- ftp://ftp.pride.ebi.ac.uk/pride/data/archive/2013/10/PXD000324
  (`5_of_5`).


```{r create_spectra_Amidan2014, echo = TRUE, eval = FALSE}

```

```{r echo = FALSE, eval = FALSE}

```

## Calculate the metrics via `MsQuality`
```{r}

```

\newpage

# References


