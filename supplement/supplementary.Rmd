---
title: "MsQuality – an interoperable open-source package for the calculation of standardized quality metrics of mass spectrometry data"
subtitle: "Supplementary Data"
author:
    - Thomas Naake^[Genome Biology Unit, European Molecular Biology Laboratory, Meyerhofstrasse 1, 69117 Heidelberg, Germany]
    - Johannes Rainer^[Institute for Biomedicine (Affiliated Institute of the University of Lübeck), Eurac Research, Viale Druso 1, 39100 Bolzano, Italy]
    - Wolfgang Huber^[Genome Biology Unit, European Molecular Biology Laboratory, Meyerhofstrasse 1, 69117 Heidelberg, Germany]
package: MsQuality

bibliography: document.bib
fontsize: 12pt
output:
  bookdown::pdf_document2:
    includes:
      in_header: "preamble.tex"
    extra_dependencies: ["natbib", "float", "lscape", "subfig", "graphicx"]
    fig_caption: true
    keep_tex: true
    citation_package: natbib
    toc_depth: 3
    number_sections: true
header-includes: 
  \usepackage{float} \floatplacement{figure}{H} 
  \newcommand{\beginsupplement}{\setcounter{table}{0}  \renewcommand{\thetable}{S\arabic{table}} \setcounter{figure}{0} \renewcommand{\thefigure}{S\arabic{figure}}}
---

\beginsupplement

\newpage

The Supplementary Information section of this publication demonstrates the 
functionality of the `MsQuality` package by presenting two example analysis 
workflows using the data sets of @Cherkaoui2022 and @Amidan2014.

The `MsQuality` package calculates low-level quality metrics that only require 
minimal information about the mass spectrometry data: retention time, m/z 
values, and associated intensities. The list of quality metrics provided by the
mzQC framework is extensive, also including metrics that depend on more 
high-level information which might not be readily accessible from .raw or 
.mzML files, such as pump pressure mean, or that rely on alignment results, 
like retention time mean shift, signal-to-noise ratio, precursor errors (ppm). 
These metrics are currently not implemented in the current version of 
`MsQuality`. 

The `MsQuality` package relies on the `Spectra` package for data import and
representation. Quality metrics are calculated based on the information
(variables) available through a `Spectra` object. The `dataOrigin` variable is
used to distinguish between the MS data from different samples/files.
The Section \ref{sec:env} loads these and other packages into the environment
of the `R` session in order to run all analyses.

In the following Sections of this Supplementary Information the quality two 
data sets will be analyzed in more detail:

The @Cherkaoui2022 data set is a mass spectrometry (MS) metabolomics data set of 
180 cancer cell lines obtained via flow injection analysis 
(TOF, negative ionization mode). The data set comprises a total of 1394 samples.
Section \ref{sec:Cherkaoui2022} analyzes this data set using the 
`MsQuality` package.

In Section \ref{sec:Amidan2014} the quality of the @Amidan2014 data set will
be assessed using the `MsQuality` package. The @Amidan2014 data set consists 
of 3400 LC-MS samples of a single QC sample 
(whole cell lysate of *Shewanella oneidensis*). The QC samples were run on 
Exactive, LTQ IonTrap, LTQ Orbitrap, and Velos Orbitrap instruments.

We would like to note that these metrics only provide an indication of data 
quality, and more advanced analytics, such as those provided by `MatrixQCvis`
[@Naake2022], should be used before removing low-quality samples from 
the analysis. As stated previously [@Bittremieux2017], the type of  QC metrics 
depend on the type of the sample, e.g. if a single peptide or a complex 
lysate of proteins is analzed [@Bereman2015,@Koecher2011,@Paulovich2010]. 
Also, data quality should always be considered in the context of 
the sample type and experimental settings, i.e. quality metrics should always 
be compared with regard to the sample type, experimental setup, instrumentation, 
etc.

In this document, we will (i) create `Spectra` objects from the raw data of the 
two datasets, (ii) calculate the quality metrics on these data sets, 
(iii) visualize some of the metrics, and (iv) assess the performance 
and scalability of the implemented algorithms using the 
`microbenchmark` package.

While the MsQuality package includes an interactive shiny application to 
navigate mass spectral data quality, with plots based on the plotly framework, 
this document will present static plots. For full reproducibility, we provide
the source .Rmd file under the accompanying
[GitHub](https://www.github.com/tnaake/MsQuality_manuscript/)
repository.

A list of the attached pacakges can be found in the Section 
\ref{sec:Session Info}.

```{r style, echo = FALSE, results = 'asis'}
BiocStyle::markdown()
```

```{r env, include=FALSE, echo=FALSE, cache=FALSE}
library("knitr")
knitr::opts_chunk$set(stop_on_error = 1L, fig.pos = "ht")
suppressPackageStartupMessages(library("Spectra"))
suppressPackageStartupMessages(library("mzR"))
suppressPackageStartupMessages(library("MsQuality"))
suppressPackageStartupMessages(library("microbenchmark"))

knitr::opts_knit$set(root.dir = "/g/huber/users/naake/GitHub/MsQuality_manuscript/supplement/")
```

# Preparation of the environment \label{sec:env}

The following analysis employs functions from several `R` packages, primarily 
the `Spectra` package for representing mass spectrometry spectral data and the 
`MsQuality` package for calculating quality metrics.
Additional packages are necessary for data visualization (`ggplot2`, 
`ggpubr`), data wrangling (`dplyr`, `readxl`, `stringr`, `tibble`, 
`tidyr`) and performance and scalability analysis
(`microbenchmark`).

To proceed with the analysis, please make sure to load these packages before 
starting using:

```{r load_package, echo = TRUE, eval = TRUE, warning=FALSE, message=FALSE}
## load packages for visualization
library("ggplot2")
library("ggpubr")

## load packages for data wrangling
library("dplyr")
library("readxl")
library("stringr")
library("tibble")
library("tidyr")

## load packages for performance and scalability analysis
library("microbenchmark")

## load packages for storing spectral data and calculating quality metrics
library("Spectra")
library("MsQuality")
```

\newpage

# @Cherkaoui2022: A functional analysis of 180 cancer cell lines reveals conserved intrinsic metabolic programs \label{sec:Cherkaoui2022}

The .mzML files were downloaded from the MassIVE database (accession number 
MSV000087155, available at https://massive.ucsd.edu/) via
ftp://massive.ucsd.edu/MSV000087155. 

## Instantiation of the Spectra object

In the subsequent analysis, a `Spectra` object is instantiated. The operations 
were executed within a high-performance computing environment, where the modified 
.mzML files were stored in the directory `Cherkaoui2022`.

```{r echo = FALSE}
setwd("/g/huber/users/naake/GitHub/MsQuality_manuscript/supplement/")
```

```{r create_spectra_Cherkaoui, eval = FALSE, echo = TRUE, cache=TRUE}
## obtain the .mzML files 
.path <- "/scratch/naake/Cherkaoui2022/"
fls <- dir(.path, full.names = TRUE, pattern = "mzML")

## create the Spectra object
sps <- Spectra(fls, backend = MsBackendMzR())
```

```{r sps_saveRDS_Cherkaoui2022, echo = FALSE, eval = FALSE}
## save the Spectra object as RDS file
saveRDS(sps, file = "../Cherkaoui2022/Cherkaoui2022_sps.RDS")
```

## Calculate the metrics via `MsQuality`

`MsQuality` utilizes `Spectra` objects that store the spectral data. In 
this particular case, where the spectral data was obtained via flow injection 
analysis, metrics that incorporate retention time information are not 
relevant and the analysis will only focus on the three metrics

 - `numberSpectra`, **Number of MS1 spectra** (QC:4000059), “The number of MS1 events in the run.” [PSI:QC];
 - `areaUnderTic`, **Area under TIC** (QC:4000077), “The area under the total ion chromatogram.” [PSI:QC];
 - `mzAcquisitionRange`, **m/z acquisition range** (QC:4000138), “Upper and lower limit of m/z values at which spectra are recorded.” [PSI:QC].


The calculation of the metrics is achieved using the function 
`calculateMetricsFromSpectra`, which takes as input the `Spectra` object, 
`sps`, and the above-defined metrics. Additionally, optional parameters 
can be passed to `calculateMetricsFromSpectra` to further specify the 
calculation, such as the `msLevel` if multiple mass spectra levels are present 
in the `Spectra` object. In the current context, where only MS1 level spectra 
are stored in the `Spectra` object, specifying the `msLevel` is not necessary.

```{r calculateMetrics_Cherkaoui2022, eval = FALSE}
.metrics <- c("numberSpectra", "areaUnderTic", "mzAcquisitionRange")

.metrics_sps <- calculateMetricsFromSpectra(spectra = sps, 
    metrics = .metrics)
```

```{r .metrics_sps_saveRDS_Cherkaoui2022, eval = FALSE, echo=FALSE}
saveRDS(.metrics_sps, file = "../Cherkaoui2022/Cherkaoui2022_metrics_sps.RDS")
```

```{r .metrics_sps_readRDS_saveRDS_Cherkaoui2022, eval = TRUE, echo = FALSE}
.metrics_sps <- readRDS("../Cherkaoui2022/Cherkaoui2022_metrics_sps.RDS")
```

## Visualization

In the analysis of the @Cherkaoui2022 study, the three quality metrics were
visualized using the `ggplot2` package. The XLSX file metabolomics_180CCL.xlsx,
downloaded from
https://www.research-collection.ethz.ch/handle/20.500.11850/511784, was used 
to extract information on the samples that were included in the subsequent 
analysis of the @Cherkaoui2022 study. This information was added to the 
`.metrics_sps` object, specifically, whether the sample was 
analyzed (`"yes"`) or excluded (`"no"`). 

A Figure was then created to compare the differences in quality metrics 
between the analyzed and excluded samples (Figure \@ref(fig:metrics-cherkaoui2022)).

```{r echo = FALSE}
## reshape the metrics into long format
.metrics_sps <- .metrics_sps |>
    as.data.frame() |>
    rownames_to_column(var = "rowname") |>
    as_tibble() |>
    pivot_longer(cols = 2:(ncol(.metrics_sps) + 1))

## for visualization purposes truncate the dataOrigin, the rowname entry
## will contain 
.metrics_sps[["rowname"]] <- .metrics_sps[["rowname"]] |>
    strsplit(split = "Cherkaoui2022/") |>
    lapply(FUN = function(names_i) names_i[[2]]) |> 
    unlist() |>
    str_remove(pattern = ".mzML")

## add information if the samples was analyzed (information stored in 
## .samples)
.samples <- read_excel(
    "../Cherkaoui2022/PrimaryAnalysis/Metabolomics_180CCL.xlsx",
    sheet = "injections")
.metrics_sps <- .metrics_sps |> 
    mutate(dsCode = sapply(
        strsplit(.metrics_sps$rowname, split = "_Batch"), "[", 1)) |>
    mutate(analyzed = ifelse(dsCode %in% .samples[["dsCode"]], "yes", "no"))
```

```{r metrics-cherkaoui2022, fig.cap = "Quality metrics for data set of @Cherkaoui2022 stratified by information if the sample was analyzed (`yes`) or excluded (`no`). (a) Area under the TIC (`areaUnderTic`). (b) Minimum values of the m/z acquisition range (`mzAcquisitionRange.min`). (c) maximum values of the m/z acquisition range `mzAcquisitionRange.max`). A.U.: arbitrary units.", echo = FALSE}
gg_areaUnderTic <- .metrics_sps |>
    filter(name == "areaUnderTic") |>
    ggplot() +
        geom_violin(aes(x = analyzed, y = value, col = analyzed)) +
        geom_point(aes(x = analyzed, y = value, col = analyzed), 
            position = position_jitter(w = 0.2, h = 0), alpha = 0.2) +
        ylab("area under TIC (A.U.)") +
        theme_classic() +
        theme(axis.title.x = element_blank(), legend.position = "none")

gg_mzRange_min <- .metrics_sps |>
    filter(name == "mzAcquisitionRange.min") |>
    ggplot() +
        geom_violin(aes(x = analyzed, y = value, col = analyzed)) +
        geom_point(aes(x = analyzed, y = value, col = analyzed), 
            position = position_jitter(w = 0.2, h = 0), alpha = 0.2) +
        ylab("minimal m/z value") +
        theme_classic() +
        theme(axis.title.x = element_blank(), legend.position = "none")

gg_mzRange_max <- .metrics_sps |>
    filter(name == "mzAcquisitionRange.max") |>
    ggplot() +
        geom_violin(aes(x = analyzed, y = value, col = analyzed)) +
        geom_point(aes(x = analyzed, y = value, col = analyzed), 
            position = position_jitter(w = 0.2, h = 0), alpha = 0.2) +
        ylab("maximal m/z value") +
        theme_classic() +
        theme(axis.title.x = element_blank(), legend.position = "none")

ggarrange(gg_areaUnderTic, ggplot() + theme_void(), 
    gg_mzRange_min, gg_mzRange_max,
    ncol = 2, nrow = 2, labels =c("a", "", "b", "c"))
```

Figure \@ref(fig:metrics-cherkaoui2022) demonstrates that the excluded 
samples show a bimodal distribution of the total ion current (TIC). 
Specifically, some of the excluded samples have lower total ion current 
(TIC) values, which was already noted in the original publication and was the 
reason for their exclusion from subsequent analysis steps. Figure
\@ref(fig:metrics-cherkaoui2022) a serves as 
a visual confirmation of this statement and aids in understanding the data 
quality of the samples. 
The metrics `mzAcquisitionRange.max` and `mzAcquisitionRange.min` on the other
hand (Figure \@ref(fig:metrics-cherkaoui2022) (b) and (c)) are not informative for 
the decision making on excluding/including samples in further analysis steps.

## Performance under parallelization

An important aspect, especially when dealing with large amount of data,
is scalability and performance when computing the quality metric. 

By monitoring parallelization, it is possible 
to determine the scalability of the computation and ensure that the 
performance of the analysis remains acceptable as the data size increases.

We measured the time it takes to evaluate the 
calculation of quality metrics under parallelizing the tasks on
1, 2, 4, 8, and 16 workers using the `microbenchmark` package. This package 
allows for precise measurement of the execution time of `R` expressions by 
repeating the evaluation multiple times and providing detailed summary 
statistics of the execution times. 

```{r df_mb_Cherkaoui2022, echo = TRUE, eval = FALSE}
.path <- "/scratch/naake/Cherkaoui2022"
fls <- dir(.path, full.names = TRUE, pattern = "mzML")

.metrics <- c("numberSpectra", "areaUnderTic", "mzAcquisitionRange")
df_mb <- microbenchmark(calculateMetricsFromSpectra(spectra = sps, 
	    metrics = .metrics, BPPARAM = MulticoreParam(workers = 1)),
    workers_2 = calculateMetricsFromSpectra(spectra = sps, 
		metrics = .metrics, BPPARAM = MulticoreParam(workers = 2)),
    workers_4 = calculateMetricsFromSpectra(spectra = sps, 
		metrics = .metrics, BPPARAM = MulticoreParam(workers = 4)),
    workers_8 = calculateMetricsFromSpectra(spectra = sps, 
	    metrics = .metrics, BPPARAM = MulticoreParam(workers = 8)),
    workers_16 = calculateMetricsFromSpectra(spectra = sps, 
	    metrics = .metrics, BPPARAM = MulticoreParam(workers = 16)), 
	times = 110L, control = list(warmup = 10), check = "equal"
)
```

```{r df_mb_saveRDS_Cherkaoui2022, eval = FALSE, echo = FALSE}
## save the data.frame
saveRDS(df_mb, file = "../Cherkaoui2022/Cherkaoui2022_df_mb.RDS")
```

```{r df_mb_readRDS_Cherkaoui2022, eval = TRUE, echo = FALSE}
df_mb <- readRDS(file = "../Cherkaoui2022/Cherkaoui2022_df_mb.RDS")
```

```{r microbenchmark-cherkaoui2022, echo = FALSE, eval = TRUE, fig.cap = "Execution time for the calculation of quality metrics of the data set of @Cherkaoui2022 under parallelization (1, 2, 4, 8, and 16 workers)."}
## convert from nano seconds to seconds
df_mb[["time"]] <- df_mb[["time"]] / 10e9
df_mb <- df_mb |>
    as.data.frame() |>
    mutate(expr = case_when(expr == "workers_1" ~ 1,
        expr == "workers_2" ~ 2, expr == "workers_4" ~ 4,
        expr == "workers_8" ~ 8, expr == "workers_16" ~ 16))

## visualize the elapsed time per amount of used workers
ggplot(df_mb) +
    geom_jitter(aes(x = expr, y = time, col = as.factor(expr)), 
        alpha = 0.2) +
    geom_violin(aes(x = expr, y = time, group = expr, fill = NA), 
        fill = alpha("white", 0)) +
    xlab("number of workers") + ylab("elapsed time (s)") +
    scale_x_continuous(breaks = df_mb[["expr"]]) +
    guides(color = guide_legend(override.aes = list(alpha = 1))) +
    theme_classic() + ylim(0, 60) +
    theme(legend.position = "none")
```

By parallelizing the calculation of the 
quality metrics across multiple workers, it is possible to significantly 
reduce the execution time, and the `microbenchmark` package was used to 
accurately measure the performance improvements achieved by parallelization
(Figure \@ref(fig:microbenchmark-cherkaoui2022)). 
The parallelization process can help in 
the management of bigger data sets, and to save valuable time in data analysis.

\newpage

# @Amidan2014: Signatures for mass spectrometry data quality \label{sec:Amidan2014}


The RAW files were downloaded from 

- ftp://ftp.pride.ebi.ac.uk/pride/data/archive/2013/10/PXD000320
  (`1_of_5`),
- ftp://ftp.pride.ebi.ac.uk/pride/data/archive/2013/10/PXD000321
  (`2_of_5`),
- ftp://ftp.pride.ebi.ac.uk/pride/data/archive/2013/10/PXD000322
  (`3_of_5`),
- ftp://ftp.pride.ebi.ac.uk/pride/data/archive/2013/10/PXD000323
  (`4_of_5`),
- ftp://ftp.pride.ebi.ac.uk/pride/data/archive/2013/10/PXD000324
  (`5_of_5`).

Subsequently, the RAW files were converted into `.mzML` files using 
MSConvertGUI (64-bit, v3.0.22015-aadd392) with setting
`peakPicking` to `vendor msLevel=1-`.

## Instantiation of the Spectra object

In the subsequent analysis, a `Spectra` object is instantiated. The operations 
were executed within a high-performance computing environment, where the modified 
.mzML files were stored in the directory `Amidan2014`.

```{r create_spectra_Amidan2014, echo = TRUE, eval = FALSE}
## read the file with protein intensities
.path <- "/scratch/naake/Amidan2014"
fls <- dir(.path, full.names = TRUE, recursive = TRUE, pattern = "mzML")

## create the Spectra object
sps <- Spectra(fls, backend = MsBackendMzR())
```

```{r sps_saveRDS_Amidan2014, echo = FALSE, eval = FALSE}
## save the Spectra object as RDS file
saveRDS(sps, file = "../Amidan2014/Amidan2014_sps.RDS")
```

## Calculate the metrics via `MsQuality`


`MsQuality` utilizes `Spectra` objects that store the spectral data. Here,
retention time information was available from the .mzML files and a higher
number of metrics could be calculated:

- *rtDuration*, **RT duration** (QC:4000053), "The retention time duration of 
  the MS run in seconds, similar to the highest scan time minus the lowest 
  scan time." [PSI:QC];
- *rtOverTicQuantiles*, **RT over TIC quantile** (QC:4000054), "The interval 
  when the respective quantile of the TIC accumulates divided by retention time 
  duration. The number of quantiles observed is given by the size of the tuple." 
  [PSI:QC];
- *rtOverMsQuarters*, **MS1 quantiles RT fraction** (QC:4000055), 
  "The interval used for acquisition of the first, second, third, and fourth 
  quarter of all MS1 events divided by RT-Duration." [PSI:QC];
- *rtOverMsQuarters*, **MS2 quantiles RT fraction** (QC:4000055), 
  "The interval used for acquisition of the first, second, third, and fourth 
  quarter of all MS2 events divided by RT-Duration." [PSI:QC];
- *ticQuartileToQuartileLogRatio*, **MS1 TIC-change quartile ratios** 
  (MS:4000057), "The log ratios of successive TIC-change quartiles. The 
  TIC changes are the list of MS1 total ion current (TIC) value changes 
  from one to the next scan, produced when each MS1 TIC is subtracted 
  from the preceding MS1 TIC. The metric's value triplet represents the 
  log ratio of the TIC-change Q2 to Q1, Q3 to Q2, TIC-change-max to Q3" 
  [PSI:MS], `mode = "TIC_change"`;
- *ticQuartileToQuartileLogRatio*, **MS1 TIC quartile ratios** (MS:4000058),
  The log ratios of successive TIC quartiles. The metric's value triplet 
  represents the log ratios of TIC-Q2 to TIC-Q1, TIC-Q3 to TIC-Q2, TIC-max to 
  TIC-Q3." [PSI:MS], `mode = "TIC";
- *numberSpectra*, **Number of MS1 spectra** (QC:4000059), 
  "The number of MS1 events in the run." [PSI:QC]; 
- *numberSpectra*, **Number of MS2 spectra** (QC:4000060), 
  "The number of MS2 events in the run." [PSI:QC];
- *medianPrecursorMz*, **Precursor median m/z for IDs** (QC:4000065), 
  "Median m/z value for all identified peptides (unique ions) after FDR." 
  [PSI:QC];
- *rtIqr*, **Interquartile RT period for peptide identifications** (QC:4000072), 
  "The interquartile retention time period, in seconds, for all peptide 
  identifications over the complete run." [PSI:QC];
- *rtIqrRate*, **Peptide identification rate of the interquartile RT period** 
  (QC:4000073), "The identification rate of peptides for the interquartile 
  retention time period, in peptides per second." [PSI:QC];
- *areaUnderTic*, **Area under TIC** (QC:4000077), "The area under the total ion
  chromatogram." [PSI:QC];
- *areaUnderTicRtQuantiles*, **Area under TIC RT quantiles** (QC:4000078), "The 
  area under the total ion chromatogram of the retention time quantiles. Number 
  of quantiles are given by the n-tuple." [PSI:QC];
- *medianTicRtIqr*, **Median of TIC values in the RT range in which the middle half of peptides are identified** 
  (QC:4000130), "Median of TIC values in the RT range in which half of peptides 
  are identified (RT values of Q1 to Q3 of identifications)" [PSI:QC];
- *medianTicOfRtRange*, **Median of TIC values in the shortest RT range in which half of the peptides are identified** 
  (QC:4000132), "Median of TIC values in the shortest RT range in which half of 
  the peptides are identified"  [PSI:QC] 
- *mzAcquisitionRange*, **m/z acquisition range** (QC:4000138), "Upper and 
  lower limit of m/z values at which spectra are recorded." [PSI:QC];
- *rtAcquisitionRange*, **Retention time acquisition range** (QC:4000139), 
  "Upper and lower limit of time at which spectra are recorded." [PSI:QC];
- *precursorIntensityRange*, **Precursor intensity range** (QC:4000144), 
  "Minimum and maximum precursor intensity recorded." [PSI:QC];
- *precursorIntensityQuartiles*, **Precursor intensity distribution Q1, Q2, Q3**
  (QC:4000167), "From the distribution of precursor intensities, the quartiles 
Q1, Q2, Q3" [PSI:QC];
- *precursorIntensityMean*, **Precursor intensity distribution mean** 
  (QC:4000168), "From the distribution of precursor intensities, the mean." 
  [PSI:QC];
- *precursorIntensitySd*, **Precursor intensity distribution sigma** 
  (QC:4000169), "From the distribution of precursor intensities, the sigma 
  value." [PSI:QC];
- *msSignal10xChange*, **MS1 signal jump (10x) count** (QC:4000172), "The 
  count of MS1 signal jump (spectra sum) by a factor of ten or more (10x) 
  between two subsequent scans" [PSI:QC];
- *RatioCharge1over2*, **Charged peptides ratio 1+ over 2+** (QC:4000174), 
  "Ratio of 1+ peptide count over 2+ peptide count in identified spectra" 
  [PSI:QC];
- *RatioCharge1over2*, **Charged spectra ratio 1+ over 2+** (QC:4000179), 
  "Ratio of 1+ spectra count over 2+ spectra count in all MS2" [PSI:QC];
- *RatioCharge3over2*, **Charged peptides ratio 3+ over 2+** (QC:4000175), 
  "Ratio of 3+ peptide count over 2+ peptide count in identified spectra" 
  [PSI:QC];
- *RatioCharge3over2*, **Charged spectra ratio 3+ over 2+** (QC:4000180), 
  "Ratio of 3+ peptide count over 2+ peptide count in all MS2" [PSI:QC];
- *RatioCharge4over2*, **Charged peptides ratio 4+ over 2+** (QC:4000176), 
  "Ratio of 4+ peptide count  over 2+ peptide count in identified spectra" 
  [PSI:QC];
- *RatioCharge4over2*, **Charged spectra ratio 4+ over 2+** (QC:4000181), 
  "Ratio of 4+ peptide count over 2+ peptide count in all MS2" [PSI:QC];
- *meanCharge*, **Mean charge in identified spectra** (QC:4000177), 
  "Mean charge in identified spectra" [PSI:QC];
- *meanCharge*, **Mean precursor charge in all MS2** (QC:4000182), 
  "Mean precursor charge in all MS2" [PSI:QC];
- *medianCharge*, **Median charge in identified spectra** (QC:4000178), 
  "Median charge in identified spectra" [PSI:QC];
- *medianCharge*, **Median precursor charge in all MS2** (QC:4000183), 
  "Median precursor charge in all MS2" [PSI:QC].

Again, the calculation of the metrics is achieved using the function \newline
`calculateMetricsFromSpectra`, which takes as input the `Spectra` object, 
`sps`, and the above-defined metrics. We calculate some of the metrics
based on their respective `msLevel` and decide here to calculate the metrics
separately for `msLevel 1` and `msLevel 2`.


```{r, eval = FALSE}
.metrics <- c("rtDuration", "rtOverTicQuantiles", "rtOverMsQuarters", 
    "ticQuartileToQuartileLogRatio", "numberSpectra", 
    "medianPrecursorMz", "rtIqr", "rtIqrRate", "areaUnderTic", 
    "areaUnderTicRtQuantiles", "medianTicRtIqr", "medianTicOfRtRange",
    "mzAcquisitionRange", "rtAcquisitionRange", "precursorIntensityRange", 
    "precursorIntensityQuartiles", "precursorIntensityMean", 
    "precursorIntensitySd", "msSignal10xChange", "ratioCharge1over2", 
    "ratioCharge3over2", "ratioCharge4over2", "meanCharge", 
    "medianCharge")

.metrics_sps_msLevel1 <- calculateMetricsFromSpectra(spectra = sps, 
    metrics = .metrics, msLevel = 1L)
.metrics_sps_msLevel1 <- calculateMetricsFromSpectra(spectra = sps, 
    metrics = .metrics, msLevel = 2L)
```


```{r .metrics_sps_saveRDS_Amidan2014, echo = FALSE, eval = FALSE}
saveRDS(.metrics_sps_msLevel1, 
    file = "../Amidan2014/Amidan2014_metrics_sps_msLevel1.RDS")
saveRDS(.metrics_sps_msLevel2, 
    file = "../Amidan2014/Amidan2014_metrics_sps_msLevel2.RDS")
```

```{r .metrics_sps_readRDS_Amidan2014, echo = FALSE, eval = TRUE}
.metrics_sps_msLevel1 <- readRDS("../Amidan2014/Amidan2014_metrics_sps_msLevel1.RDS")
.metrics_sps_msLevel2 <- readRDS("../Amidan2014/Amidan2014_metrics_sps_msLevel2.RDS")
```

Overall, this function provides a flexible and 
efficient way to analyze large amounts of mass spectrometry data and obtain 
insights on the quality of the data.

## Visualization

In the analysis of the @Amidan2014 study, the quality metrics were
visualized using the `ggplot2` package. The XLS files pr401143e_si_002.xls
and pr401143e_si_003.xls (provided as Supplemental Material of the original
publication) was used to extract information on the sample quality.
This information was added to the `.metrics_sps_msLevel1` and 
`.metrics_sps_msLevel2` objects.

The Figures \@ref(fig:areaUnderTic-amidan2014), 
\@ref(fig:areaUnderTicRtQuantiles-amidan2014), and
\@ref(fig:ticQuartileToQuartileLogRatio-amidan2014) were created as examples 
to compare the differences between the low- and high-quality samples samples 
for several of the supported quality metrics.

```{r join_metrics_and_metadata, echo = FALSE}
## reshape the metrics into long format
.metrics_sps_msLevel1 <- .metrics_sps_msLevel1 |>
    as.data.frame() |>
    rownames_to_column(var = "rowname") |>
    as_tibble()
.metrics_sps_msLevel2 <- .metrics_sps_msLevel2 |>
    as.data.frame() |>
    rownames_to_column(var = "rowname") |>
    as_tibble()

## for visualization purposes truncate the dataOrigin, the rowname entry
## will contain 
.metrics_sps_msLevel1[["rowname"]] <- .metrics_sps_msLevel1[["rowname"]] |>
    strsplit(split = "Amidan2014/[1-5]_of_5/", fixed = FALSE) |>
    lapply(FUN = function(names_i) names_i[[2]]) |> 
    unlist() |>
    str_remove(pattern = ".mzML")
.metrics_sps_msLevel2[["rowname"]] <- .metrics_sps_msLevel2[["rowname"]] |>
    strsplit(split = "Amidan2014/[1-5]_of_5/", fixed = FALSE) |>
    lapply(FUN = function(names_i) names_i[[2]]) |> 
    unlist() |>
    str_remove(pattern = ".mzML")

## add here information on the classification of samples (information stored in 
## .samples)
.samples_training <- read_excel("../Amidan2014/pr401143e_si_002.xls",
    sheet = "FileS1_TrainingDataset")
.samples_validation <- read_excel("../Amidan2014/pr401143e_si_003.xls",
    sheet = "FileS2_ValidationDataset")
.cols <- intersect(colnames(.samples_training), 
    colnames(.samples_validation))
.samples <- rbind(.samples_training[, .cols], .samples_validation[, .cols])

.metrics_sps_msLevel1 <- left_join(.metrics_sps_msLevel1, .samples, 
    by = c("rowname" = "Dataset"), copy = TRUE)
.metrics_sps_msLevel2 <- left_join(.metrics_sps_msLevel2, .samples, 
    by = c("rowname" = "Dataset"), copy = TRUE)
```

```{r helper_function_plot_densities, eval = TRUE, echo = FALSE}
library(patchwork)

plot_densities <- function(metrics, 
    selected_metric = "areaUnderTicRtQuantiles.25%", 
    ylim = c(0, 1.2e12), xlim = c(2.7, 7)) {

    .levels <- c("good", "poor")
    P <- list()
    
    for (i in seq_along(.levels)) {
        P[[i]] <- metrics |>
            filter(!duplicated(rowname)) |>
            select(rowname, Curated_Quality, rtDuration, 
                selected_metric) |>
            filter(Curated_Quality %in% .levels[i]) |>
            mutate(rtDuration = rtDuration / 1000) |>
            pivot_longer(cols = selected_metric) |>
            ggplot(aes(x = rtDuration, y = value)) +
                stat_density_2d(aes(fill = after_stat(level)), geom = "polygon") +
                facet_wrap(~ Curated_Quality, scales = "fixed") +
                xlim(xlim) + ylim(ylim) + 
                theme_classic() +
                theme(legend.position = "none", axis.title = element_blank(),
                    plot.margin=unit(c(-0.1, 0.5, -1.9, 0), "cm"))# +
        #theme(plot.margin = unit(c(0.5,0.5,0.5,-0.5), "cm"))
        
        if (i == 2) 
            P[[i]] <- P[[i]] + 
                theme(axis.text.y = element_blank(), 
                    axis.ticks.y = element_blank(), 
                    plot.margin=unit(c(-0.1, 1, -1.9, 0), "cm"))
        P[[i]]
    }
    
    P[[1]] + P[[2]]
}
```


```{r areaUnderTic-amidan2014, fig.cap = "Quality metrics by `MsQuality`: Area under TIC (`areaUnderTic`). The `MsQuality` metrics are calculated from MS1 and MS2 spectra. One data point is obtained per MS1 and MS2 spectra and the data points are displayed as 2D densities stratified for high-quality and low-quality samples as classified in @Amidan2014. (a) Area under TIC for MS1 spectra. (b) Area under TIC for MS2 spectra. A.U.: arbitrary units.", warning = FALSE, echo = FALSE}
xlim <- c(2.5, 7.5)
## area under TIC
gg_tic_msLevel1 <- plot_densities(metrics = .metrics_sps_msLevel1, 
      selected_metric = "areaUnderTic", ylim = c(0, 8e12), xlim = xlim)
gg_tic_msLevel2 <- plot_densities(metrics = .metrics_sps_msLevel2, 
      selected_metric = "areaUnderTic", ylim = c(0, 16e10), xlim = xlim)

p <- ggarrange(gg_tic_msLevel1, gg_tic_msLevel2, ncol = 2, nrow = 1, 
    labels = "auto")
annotate_figure(p, top = text_grob("area under TIC (A.U.)"),
    bottom = "RT duration (s, in 10e3)")
```

```{r areaUnderTicRtQuantiles-amidan2014, fig.cap = "Quality metrics by `MsQuality`: Area under TIC RT quantiles (`areaUnderTicRtQuantiles`). The `MsQuality` metrics are calculated from MS1 and MS2 spectra. One data point is obtained per MS1 and MS2 spectra and the data points are displayed as 2D densities stratified for high-quality and low-quality samples as classified in @Amidan2014. (a) 25% quantile for MS1 spectra. (b) 25% quantile for MS2 spectra. (c) 50% quantile for MS1 spectra. (d) 50% quantile for MS2 spectra.E: 75% quantile for MS1 spectra. (f) 75% quantile for MS2 spectra. (g) 100% quantile for MS1 spectra. (h) 100% quantile for MS2 spectra.", warning = FALSE, echo = FALSE, fig.height = 7}
xlim <- c(2.5, 7.5)
## areaUnderTicRtQuantiles
## areaUnderTicRtQuantiles 25%
gg_tic25_msLevel1 <- plot_densities(metrics = .metrics_sps_msLevel1, 
    selected_metric = "areaUnderTicRtQuantiles.25%", ylim = c(0, 1.2e12), 
    xlim = xlim)

gg_tic25_msLevel2 <- plot_densities(metrics = .metrics_sps_msLevel2, 
    selected_metric = "areaUnderTicRtQuantiles.25%", ylim = c(0, 3.2e10), 
    xlim = xlim)

## areaUnderTicRtQuantiles 50%
gg_tic50_msLevel1 <- plot_densities(metrics = .metrics_sps_msLevel1, 
    selected_metric = "areaUnderTicRtQuantiles.50%", ylim = c(0, 3e12), 
    xlim = xlim)
gg_tic50_msLevel2 <- plot_densities(metrics = .metrics_sps_msLevel2, 
    selected_metric = "areaUnderTicRtQuantiles.50%", ylim = c(0, 8e10), 
    xlim = xlim)


## areaUnderTicRtQuantiles 75%
gg_tic75_msLevel1 <- plot_densities(metrics = .metrics_sps_msLevel1, 
    selected_metric = "areaUnderTicRtQuantiles.75%", ylim = c(0, 4e12), 
    xlim = xlim)
gg_tic75_msLevel2 <- plot_densities(metrics = .metrics_sps_msLevel2, 
    selected_metric = "areaUnderTicRtQuantiles.75%", ylim = c(0, 4.5e10), 
    xlim = xlim)
  
## areaUnderTicRtQuantiles 100%
gg_tic100_msLevel1 <- plot_densities(metrics = .metrics_sps_msLevel1, 
    selected_metric = "areaUnderTicRtQuantiles.100%", ylim = c(0, 12e11), 
    xlim = xlim)
gg_tic100_msLevel2 <- plot_densities(metrics = .metrics_sps_msLevel2, 
    selected_metric = "areaUnderTicRtQuantiles.100%", ylim = c(0, 1.2e10), 
    xlim = xlim)

row1 <- ggarrange(
    annotate_figure(ggarrange(gg_tic25_msLevel1, labels = "a"), top = "MS1", 
        left = "25%"),
    annotate_figure(ggarrange(gg_tic25_msLevel2, labels = "b"), top = "MS2"),
    ncol = 2, nrow = 1)
row2 <- ggarrange(
    annotate_figure(ggarrange(gg_tic50_msLevel1, labels = "c"), left = "50%"),
    annotate_figure(ggarrange(gg_tic50_msLevel2, labels = "d")),
    ncol = 2, nrow = 1)
row3 <- ggarrange(
    annotate_figure(ggarrange(gg_tic75_msLevel1, labels = "e"), 
        left = "75%"),
    annotate_figure(ggarrange(gg_tic75_msLevel2, labels = "f")),
    ncol = 2, nrow = 1)
row4 <- ggarrange(
    annotate_figure(ggarrange(gg_tic100_msLevel1, labels = "g"), 
        left = "100%"),
    annotate_figure(ggarrange(gg_tic100_msLevel2, labels = "h")),
    ncol = 2, nrow = 1)
p <- ggarrange(row1, row2, row3, row4, ncol = 1, nrow = 4, align = "v")

annotate_figure(p, top = text_grob("area under TIC RT quantile"),
    bottom = "RT duration (s, in 10e3)")

```

```{r ticQuartileToQuartileLogRatio-amidan2014, fig.cap = "Quality metrics by `MsQuality`: TIC quartile to quartile log ratio (`ticQuartileToQuartileLogRatio`). The `MsQuality` metrics are calculated from MS1 and MS2 spectra. One data point is obtained per MS1 and MS2 spectra and the data points are displayed as 2D densities stratified for high-quality and low-quality samples as classified in @Amidan2014. (a) log ratio of quartile 2 to quartile 1 for MS1 spectra. (b) log ratio of quartile 3 to quartile 2 for MS1 spectra. (c) log ratio of quartile 4 to quartile 3 for MS1 spectra. (d) log ratio of quartile 2 to quartile 1 for MS2 spectra. (e) log ratio of quartile 3 to quartile 2 for MS2 spectra. (f) log ratio of quartile 4 to quartile 3 for MS1 spectra.", warning = FALSE, echo = FALSE}

xlim <- c(2.5, 7.5)
## ticQuartileToQuartileLogRatio
## ticQuartileToQuartileLogRatio Q2/Q1%
gg_tic_q2_msLevel1 <- plot_densities(metrics = .metrics_sps_msLevel1, 
    selected_metric = "ticQuartileToQuartileLogRatio.Q2/Q1", ylim = c(0, 3.5), 
    xlim = xlim)
gg_tic_q2_msLevel2 <- plot_densities(metrics = .metrics_sps_msLevel2, 
    selected_metric = "ticQuartileToQuartileLogRatio.Q2/Q1", ylim = c(0, 3.5), 
    xlim = xlim)
  
## ticQuartileToQuartileLogRatio.Q3/Q2
gg_tic_q3_msLevel1 <- plot_densities(metrics = .metrics_sps_msLevel1, 
    selected_metric = "ticQuartileToQuartileLogRatio.Q3/Q2", ylim = c(0, 3), 
    xlim = xlim)
gg_tic_q3_msLevel2 <- plot_densities(metrics = .metrics_sps_msLevel2, 
    selected_metric = "ticQuartileToQuartileLogRatio.Q3/Q2", ylim = c(0, 3), 
    xlim = xlim)

## ticQuartileToQuartileLogRatio.Q4/Q3
gg_tic_q4_msLevel1 <- plot_densities(metrics = .metrics_sps_msLevel1, 
    selected_metric = "ticQuartileToQuartileLogRatio.Q4/Q3", ylim = c(0, 3), 
    xlim = xlim)
gg_tic_q4_msLevel2 <- plot_densities(metrics = .metrics_sps_msLevel2, 
    selected_metric = "ticQuartileToQuartileLogRatio.Q4/Q3", ylim = c(1.9, 7.8), 
    xlim = xlim)

row1 <- ggarrange(
    annotate_figure(ggarrange(gg_tic_q2_msLevel1, labels = "a"), top = "Q2/Q1"),
    annotate_figure(ggarrange(gg_tic_q3_msLevel1, labels = "b"), top = "Q3/Q2"),
    annotate_figure(ggarrange(gg_tic_q4_msLevel1, labels = "c"), top = "Q4/Q3"),
    ncol = 3, nrow = 1) |>
    annotate_figure(left = "MS1")
row2 <- ggarrange(
    annotate_figure(ggarrange(gg_tic_q2_msLevel2, labels = "d")), 
    annotate_figure(ggarrange(gg_tic_q3_msLevel2, labels = "e")),
    annotate_figure(ggarrange(gg_tic_q4_msLevel2, labels = "f")),
    ncol = 3, nrow = 1) |>
    annotate_figure(left = "MS2")
p <- ggarrange(row1, row2, ncol = 1, nrow = 2)

annotate_figure(p, top = text_grob("TIC quartile to quartile log ratio"),
    bottom = "RT duration (s, in 10e3)")
```

The Figures \@ref(fig:areaUnderTic-amidan2014) and
\@ref(fig:areaUnderTicRtQuantiles-amidan2014) demonstrate that the 
low-quality samples (`poor`) have 
lower total ion current (TIC) values compared to high-quality samples (`good`). 
The Figures serve as a visual check to differences in TIC values and aids in 
understanding the data quality of the samples. It has to be pointed out that 
a further stratification (e.g. along the instrument type) might be helpful 
to further point out differences between the levels of data quality of the
@Amidan2014 data set.

The Figure \@ref(fig:ticQuartileToQuartileLogRatio-amidan2014) on the other 
hand does not indicate differences between data quality and might 
not be indicate of data quality for the quality issues of the @Amidan2014 data 
set.

### Comparison to QuaMeter metrics

The XLS files also contain pre-calculated `QuaMeter` metrics [@Ma2012] for each of 
the samples. In the following, we will compare the `QuaMeter`-metrics to the
`MsQuality` metrics to check if `MsQuality` shows concordant results
compared to `QuaMeter`.

```{r rtDurationComparison-amidan2014, fig.cap = "Comparison of quality metrics calculated by `MsQuality` and `QuaMeter`: RT duration (`rtDuration`). The corresponding metric for `QuaMeter` is `RT_Duration` (no specification if the metric was calculated on MS1 and/or MS2 spectra). The `MsQuality` metrics are calculated from MS1 and MS2 spectra. One data point is obtained per MS1 and MS2 spectra and the data points are displayed on the x- and y-axis. (a) RT duration for MS1 spectra (`QuaMeter` metric: `RT_Duration`). (b) RT duration for MS2 spectra (`QuaMeter` metric: `RT_Duration`).", echo = FALSE}
## rtDuration (MsQuality) vs. RT_Duration (QuaMeter)
gg_rt_msLevel1 <- .metrics_sps_msLevel1 |>
    filter(!is.na(Curated_Quality)) |>
    ggplot(aes(x = rtDuration, y = RT_Duration)) +
        geom_point(alpha = 0.2) +
        xlab("MsQuality (MS1)") + ylab("QuaMeter") +
        theme_classic() +
        xlim(0, 40000) + ylim(0, 40000) +
        guides(colour = guide_legend(override.aes = list(alpha = 1)))

gg_rt_msLevel2 <- .metrics_sps_msLevel2 |>
    filter(!is.na(Curated_Quality)) |>
    ggplot(aes(x = rtDuration, y = RT_Duration)) +
        geom_point(alpha = 0.2) +
        xlab("MsQuality (MS2)") + ylab("QuaMeter") +
        theme_classic() +
        xlim(0, 40000) + ylim(0, 40000) +
        guides(colour = guide_legend(override.aes = list(alpha = 1)))

p <- ggarrange(gg_rt_msLevel1, gg_rt_msLevel2, ncol = 2, nrow = 1, labels = "auto")
annotate_figure(p, top = text_grob("RT duration (s)"))

cor_rtDuration_p <- cor.test(.metrics_sps_msLevel1[["rtDuration"]], .metrics_sps_msLevel1[["RT_Duration"]], method = "pearson")
cor_rtDuration_s <- cor.test(.metrics_sps_msLevel1[["rtDuration"]], .metrics_sps_msLevel1[["RT_Duration"]], method = "spearman")
```


```{r numberSpectraComparison-amidan2014, fig.cap = "Comparison of quality metrics calculated by `MsQuality` and `QuaMeter`: Number of spectra (`numberSpectra`). The corresponding metrics for `QuaMeter` are `MS1_Count` and `MS2_Count`. The `MsQuality` metrics are calculated from MS1 and MS2 spectra. One data point is obtained per MS1 and MS2 spectra and the data points are displayed on the x- and y-axis. (a) Number of MS1 spectra (`QuaMeter` metric: `MS1_Count`). (b) Number of MS2 spectra (`QuaMeter` metric: `MS2_Count`).", echo = FALSE}
## 
##  numberSpectra (MsQuality) vs. MS1_Count (QuaMeter)
gg_numberSpectra_msLevel1 <- .metrics_sps_msLevel1 |>
    filter(!is.na(Curated_Quality)) |>
    ggplot(aes(x = numberSpectra, y = MS1_Count)) +
        geom_point(alpha = 0.2) +
        xlab("MsQuality") + ylab("QuaMeter") +
        theme_classic() +
        guides(colour = guide_legend(override.aes = list(alpha = 1)))

##  numberSpectra (MsQuality) vs. MS2_Count (QuaMeter)
gg_numberSpectra_msLevel2 <- .metrics_sps_msLevel2 |>
    filter(!is.na(Curated_Quality)) |>
    ggplot(aes(x = numberSpectra, y = MS2_Count)) +
        geom_point(alpha = 0.2) +
        xlab("MsQuality") + ylab("QuaMeter") +
        theme_classic() +
        guides(colour = guide_legend(override.aes = list(alpha = 1)))


col1 <- annotate_figure(ggarrange(gg_numberSpectra_msLevel1, labels = "a"), 
    top = "MS1") 
col2 <- annotate_figure(ggarrange(gg_numberSpectra_msLevel2, labels = "b"),
    top = "MS2")

p <- ggarrange(col1, col2, ncol = 2, nrow = 1)
annotate_figure(p, top = text_grob("number of spectra"))

## calculate correlation
cor_numberSpectra_msLevel1_p <- cor.test(
    .metrics_sps_msLevel1[["numberSpectra"]],
    .metrics_sps_msLevel1[["MS1_Count"]], method = "pearson")
cor_numberSpectra_msLevel1_s <- cor.test(
    .metrics_sps_msLevel1[["numberSpectra"]],
    .metrics_sps_msLevel1[["MS1_Count"]], method = "spearman")
cor_numberSpectra_msLevel2_p <- cor.test(
    .metrics_sps_msLevel2[["numberSpectra"]],
    .metrics_sps_msLevel2[["MS2_Count"]], method = "pearson")
cor_numberSpectra_msLevel2_s <- cor.test(
    .metrics_sps_msLevel2[["numberSpectra"]], 
    .metrics_sps_msLevel2[["MS2_Count"]], method = "spearman")
```

```{r rtOverTicQuantilesComparison-amidan2014, fig.cap = "Scatterplot between quality metrics calculated by `MsQuality` and `QuaMeter`: RT over TIC quantile (`rtOverTicQuantiles`). The corresponding metrics for `QuaMeter` are `RT_TIC_Q1`, `RT_TIC_Q2`, and `RT_TIC_Q3` (no specification if these metrices were calculated on MS1 and/or MS2 spectra). The `MsQuality` metrics are calculated from MS1 and MS2 spectra. One data point is obtained per MS1 and MS2 spectra and the data points are displayed as 2D densities. Brighter areas correspond to high 2D density areas. (a) 25% quantile for MS1 spectra (`QuaMeter` metric: `RT_TIC_Q1`). (b) 50% quantile for MS1 spectra (`QuaMeter` metric: `RT_TIC_Q2`). (c) 75% quantile for MS1 spectra (`QuaMeter` metric: `RT_TIC_Q3`). (d) 25% quantile for MS2 spectra (`QuaMeter` metric: `RT_TIC_Q1`). (e) 50% quantile for MS2 spectra (`QuaMeter` metric: `RT_TIC_Q2`). (f) 75% quantile for MS2 spectra (`QuaMeter` metric: `RT_TIC_Q3`).", warning = FALSE, echo = FALSE}

.bins <- 20
## 
##  rtOverTicQuantiles (MsQuality) vs. RT_TIC_Q1 (QuaMeter)
gg_rt_tic_q1_msLevel1 <- .metrics_sps_msLevel1 |>
    filter(!is.na(Curated_Quality)) |>
    mutate(RT_TIC_Q1 = RT_TIC_Q1) |>
    ggplot(aes(x = `rtOverTicQuantiles.25%`, y = RT_TIC_Q1)) +
        stat_density_2d(aes(fill = after_stat(level)), geom = "polygon", bins = .bins) +
        xlab("MsQuality") + ylab("QuaMeter") +
        coord_fixed(ratio = 1) +
        theme_classic() +
        theme(legend.position = "none")

gg_rt_tic_q1_msLevel2 <- .metrics_sps_msLevel2 |>
    filter(!is.na(Curated_Quality)) |>
    mutate(RT_TIC_Q1 = RT_TIC_Q1) |>
    ggplot(aes(x = `rtOverTicQuantiles.25%`, y = RT_TIC_Q1)) +
        stat_density_2d(aes(fill = after_stat(level)), geom = "polygon", bins = .bins) +
        xlab("MsQuality") + ylab("QuaMeter") +
        coord_fixed(ratio = 1) +
        theme_classic() +
        theme(legend.position = "none")

##  rtOverTicQuantiles (MsQuality) vs. RT_TIC_Q2 (QuaMeter)
gg_rt_tic_q2_msLevel1 <- .metrics_sps_msLevel1 |>
    filter(!is.na(Curated_Quality)) |>
    mutate(RT_TIC_Q2 = RT_TIC_Q1 + RT_TIC_Q2) |>
    ggplot(aes(x = `rtOverTicQuantiles.50%`, y = RT_TIC_Q2)) +
        stat_density_2d(aes(fill = after_stat(level)), geom = "polygon", bins = .bins) +
        xlab("MsQuality") + ylab("QuaMeter") +
        coord_fixed(ratio = 1) +
        theme_classic() +
        theme(legend.position = "none")

gg_rt_tic_q2_msLevel2 <- .metrics_sps_msLevel2 |>
    filter(!is.na(Curated_Quality)) |>
    mutate(RT_TIC_Q2 = RT_TIC_Q1 + RT_TIC_Q2) |>
    ggplot(aes(x = `rtOverTicQuantiles.50%`, y = RT_TIC_Q2)) +
        stat_density_2d(aes(fill = after_stat(level)), geom = "polygon", bins = .bins) +
        xlab("MsQuality") + 
        ylab("QuaMeter") +
        coord_fixed(ratio = 1) +
        theme_classic() +
        theme(legend.position = "none")

##  rtOverTicQuantiles (MsQuality) vs. RT_TIC_Q3 (QuaMeter)
gg_rt_tic_q3_msLevel1 <- .metrics_sps_msLevel1 |>
    filter(!is.na(Curated_Quality)) |>
    mutate(RT_TIC_Q3 = RT_TIC_Q1 + RT_TIC_Q2 + RT_TIC_Q3) |>
    ggplot(aes(x = `rtOverTicQuantiles.75%`, y = RT_TIC_Q3)) +
        stat_density_2d(aes(fill = after_stat(level)), geom = "polygon", bins = .bins) +
        xlab("MsQuality") + 
        ylab("QuaMeter") +
        coord_fixed(ratio = 1) +
        theme_classic() +
        theme(legend.position = "none")

gg_rt_tic_q3_msLevel2 <- .metrics_sps_msLevel2 |>
    filter(!is.na(Curated_Quality)) |>
    mutate(RT_TIC_Q3 = RT_TIC_Q1 + RT_TIC_Q2 + RT_TIC_Q3) |>
    ggplot(aes(x = `rtOverTicQuantiles.75%`, y = RT_TIC_Q3)) +
        stat_density_2d(aes(fill = after_stat(level)), geom = "polygon", bins = .bins) +
        xlab("MsQuality") + 
        ylab("QuaMeter") +
        coord_fixed(ratio = 1) +
        theme_classic() +
        theme(legend.position = "none")

row1 <- ggarrange(
    annotate_figure(ggarrange(gg_rt_tic_q1_msLevel1, labels = "a"), top = "25%"),
    annotate_figure(ggarrange(gg_rt_tic_q2_msLevel1, labels = "b"), top = "50%"),
    annotate_figure(ggarrange(gg_rt_tic_q3_msLevel1, labels = "c"), top = "75%"),
    ncol = 3, nrow = 1) |>
    annotate_figure(left = "MS1")
row2 <- ggarrange(
    annotate_figure(ggarrange(gg_rt_tic_q1_msLevel2, labels = "d")), 
    annotate_figure(ggarrange(gg_rt_tic_q2_msLevel2, labels = "e")),
    annotate_figure(ggarrange(gg_rt_tic_q3_msLevel2, labels = "f")),
    ncol = 3, nrow = 1) |>
    annotate_figure(left = "MS2")
p <- ggarrange(row1, row2, ncol = 1, nrow = 2)

annotate_figure(p, top = text_grob("RT over TIC Quantiles"))


## calculate correlation
cor_rt_tic_q1_msLevel1_p <- cor.test(
    .metrics_sps_msLevel1[["rtOverTicQuantiles.25%"]],
    .metrics_sps_msLevel1[["RT_TIC_Q1"]], method = "pearson")
cor_rt_tic_q1_msLevel1_s <- cor.test(
    .metrics_sps_msLevel1[["rtOverTicQuantiles.25%"]],
    .metrics_sps_msLevel1[["RT_TIC_Q1"]], method = "spearman")
cor_rt_tic_q1_msLevel2_p <- cor.test(
    .metrics_sps_msLevel2[["rtOverTicQuantiles.25%"]],
    .metrics_sps_msLevel2[["RT_TIC_Q1"]], method = "pearson")
cor_rt_tic_q1_msLevel2_s <- cor.test(
    .metrics_sps_msLevel2[["rtOverTicQuantiles.25%"]], 
    .metrics_sps_msLevel2[["RT_TIC_Q1"]], method = "spearman")

tmp <- .metrics_sps_msLevel1[["RT_TIC_Q1"]] + 
    .metrics_sps_msLevel1[["RT_TIC_Q2"]]
cor_rt_tic_q2_msLevel1_p <- cor.test(
    .metrics_sps_msLevel1[["rtOverTicQuantiles.50%"]], tmp, method = "pearson")
cor_rt_tic_q2_msLevel1_s <- cor.test(
    .metrics_sps_msLevel1[["rtOverTicQuantiles.50%"]], tmp, method = "spearman")
cor_rt_tic_q2_msLevel2_p <- cor.test(
    .metrics_sps_msLevel2[["rtOverTicQuantiles.50%"]], tmp, method = "pearson")
cor_rt_tic_q2_msLevel2_s <- cor.test(
    .metrics_sps_msLevel2[["rtOverTicQuantiles.50%"]], tmp , method = "spearman")

tmp <- .metrics_sps_msLevel1[["RT_TIC_Q1"]] + 
    .metrics_sps_msLevel1[["RT_TIC_Q2"]] +
    .metrics_sps_msLevel1[["RT_TIC_Q3"]]
cor_rt_tic_q3_msLevel1_p <- cor.test(
    .metrics_sps_msLevel1[["rtOverTicQuantiles.75%"]], tmp, method = "pearson")
cor_rt_tic_q3_msLevel1_s <- cor.test(
    .metrics_sps_msLevel1[["rtOverTicQuantiles.75%"]], tmp, method = "spearman")
cor_rt_tic_q3_msLevel2_p <- cor.test(
    .metrics_sps_msLevel2[["rtOverTicQuantiles.75%"]], tmp, method = "pearson")
cor_rt_tic_q3_msLevel2_s <- cor.test(
    .metrics_sps_msLevel2[["rtOverTicQuantiles.75%"]], tmp, method = "spearman")
```

```{r rtOverTicQuantilesComparisonOnePlot-amidan2014, fig.cap = "Comparison of quality metrics calculated by `MsQuality` and `QuaMeter`: RT over TIC quantiles (`rtOverTicQuantiles`). The `MsQuality` metrics are calculated from MS1 and MS2 spectra. One data point is obtained per MS1 and MS2 spectra and the data points are displayed as 2D densities stratified by quantiles 25%, 50%, and 75%. (a) Quantiles for MS1 spectra. (b) Quantile for MS2 spectra.", warning = FALSE, echo = FALSE, fig.show='hide'}
## combine Q1, Q2, and Q3 in one plot per msLevel
gg_rt_tic_msLevel1 <- .metrics_sps_msLevel1 |>
    filter(!is.na(Curated_Quality)) |>
    mutate(RT_TIC_Q2 = RT_TIC_Q1 + RT_TIC_Q2) |>
    mutate(RT_TIC_Q3 = RT_TIC_Q2 + RT_TIC_Q3) |>
    select(rowname,  `rtOverTicQuantiles.25%`, `rtOverTicQuantiles.50%`, 
        `rtOverTicQuantiles.75%`, RT_TIC_Q1, RT_TIC_Q2, RT_TIC_Q3) |>
    rename("25%_rtOverTicQuantiles" = `rtOverTicQuantiles.25%`,
        "50%_rtOverTicQuantiles" = `rtOverTicQuantiles.50%`,
        "75%_rtOverTicQuantiles" = `rtOverTicQuantiles.75%`,
        "25%_RTTIC" = RT_TIC_Q1, "50%_RTTIC" = RT_TIC_Q2, 
        "75%_RTTIC" = RT_TIC_Q3) |>
    pivot_longer(-rowname, names_to = c("Quantile", ".value"), names_sep = "_") |>
    ggplot(aes(x = rtOverTicQuantiles, y = RTTIC)) +
        stat_density_2d(aes(color = Quantile)) +
        xlab("MsQuality (MS1)") + 
        ylab("QuaMeter") +
        xlim(0, 1) + ylim(0, 1) +
        theme_classic() +
        guides(colour = guide_legend(override.aes = list(alpha = 1)))

gg_rt_tic_msLevel2 <- .metrics_sps_msLevel2 |>
    filter(!is.na(Curated_Quality)) |>
    mutate(RT_TIC_Q2 = RT_TIC_Q1 + RT_TIC_Q2) |>
    mutate(RT_TIC_Q3 = RT_TIC_Q2 + RT_TIC_Q3) |>
    select(rowname,  `rtOverTicQuantiles.25%`, `rtOverTicQuantiles.50%`, 
        `rtOverTicQuantiles.75%`, RT_TIC_Q1, RT_TIC_Q2, RT_TIC_Q3) |>
    rename("25%_rtOverTicQuantiles" = `rtOverTicQuantiles.25%`,
        "50%_rtOverTicQuantiles" = `rtOverTicQuantiles.50%`,
        "75%_rtOverTicQuantiles" = `rtOverTicQuantiles.75%`,
        "25%_RTTIC" = RT_TIC_Q1, "50%_RTTIC" = RT_TIC_Q2, 
        "75%_RTTIC" = RT_TIC_Q3) |>
    pivot_longer(-rowname, names_to = c("Quantile", ".value"), names_sep = "_") |>
    ggplot(aes(x = rtOverTicQuantiles, y = RTTIC)) +
        stat_density_2d(aes(color = Quantile)) +
        xlab("MsQuality (MS2)") + 
        ylab("QuaMeter") +
        xlim(0, 1) + ylim(0, 1) +
        theme_classic() +
        guides(colour = guide_legend(override.aes = list(alpha = 1)))

p <- ggarrange(gg_rt_tic_msLevel1, gg_rt_tic_msLevel2,
    ncol = 2, nrow = 1, labels = "auto")
annotate_figure(p, top = text_grob("RT over TIC quantiles"))
```


```{r rtOverMsQuartersComparison-amidan2014, fig.cap = "Comparison of quality metrics calculated by `MsQuality` and `QuaMeter`: RT over MS quarters (`rtOverMsQuarters`). The `MsQuality` metrics are calculated from MS1 and MS2 spectra. One data point is obtained per MS1 and MS2 spectra and the data points are displayed as 2D densities. Brighter areas correspond to high 2D density areas. (a) Quarter 1 for MS1 spectra. (b) Quarter 2 for MS1 spectra. (c) Quarter 3 for MS1 spectra. (d) Quarter 1 for MS2 spectra. (e) Quarter 2 for MS2 spectra. (f) Quarter 3 for MS2 spectra. Q: quarter.", warning = FALSE, echo = FALSE}

.bins <- 20
##
## rtOverMsQuarters vs RT_MS_Q1
gg_rt_msQuarters_q1_msLevel1 <- .metrics_sps_msLevel1 |>
    filter(!is.na(Curated_Quality)) |>
    ggplot(aes(x = `rtOverMsQuarters.Quarter1`, y = RT_MS_Q1)) +
        stat_density_2d(aes(fill = after_stat(level)), geom = "polygon", bins = .bins) +
        xlab("MsQuality") + 
        ylab("QuaMeter") +
        coord_fixed(ratio = 1) +
        theme_classic() +
        theme(legend.position = "none")

## rtOverMsQuarters vs RT_MS_Q2
gg_rt_msQuarters_q2_msLevel1 <- .metrics_sps_msLevel1 |>
    filter(!is.na(Curated_Quality)) |>
    mutate(RT_MS_Q2 = RT_MS_Q1 + RT_MS_Q2) |>
    ggplot(aes(x = `rtOverMsQuarters.Quarter2`, y = RT_MS_Q2)) +
        stat_density_2d(aes(fill = after_stat(level)), geom = "polygon", bins = .bins) +
        xlab("MsQuality") + 
        ylab("QuaMeter") +
        coord_fixed(ratio = 1) +
        theme_classic() +
        theme(legend.position = "none")

## rtOverMsQuarters vs RT_MS_Q3
gg_rt_msQuarters_q3_msLevel1 <- .metrics_sps_msLevel1 |>
    filter(!is.na(Curated_Quality)) |>
    mutate(RT_MS_Q3 = RT_MS_Q1 + RT_MS_Q2 + RT_MS_Q3) |>
    ggplot(aes(x = `rtOverMsQuarters.Quarter3`, y = RT_MS_Q3)) +
        stat_density_2d(aes(fill = after_stat(level)), geom = "polygon", bins = .bins) +
        xlab("MsQuality") + 
        ylab("QuaMeter") +
        coord_fixed(ratio = 1) +
        theme_classic() +
        theme(legend.position = "none")

##
## rtOverMsQuarters vs RT_MSMS_Q1
gg_rt_msQuarters_q1_msLevel2 <- .metrics_sps_msLevel2 |>
    filter(!is.na(Curated_Quality)) |>
    ggplot(aes(x = `rtOverMsQuarters.Quarter1`, y = RT_MSMS_Q1)) +
        stat_density_2d(aes(fill = after_stat(level)), geom = "polygon", bins = .bins) +
        xlab("MsQuality") + 
        ylab("QuaMeter") +
        coord_fixed(ratio = 1) +
        theme_classic() +
        theme(legend.position = "none")

## rtOverMsQuarters vs RT_MSMS_Q2
gg_rt_msQuarters_q2_msLevel2 <- .metrics_sps_msLevel2 |>
    filter(!is.na(Curated_Quality)) |>
    mutate(RT_MSMS_Q2 = RT_MSMS_Q1 + RT_MSMS_Q2) |>
    ggplot(aes(x = `rtOverMsQuarters.Quarter2`, y = RT_MSMS_Q2)) +
        stat_density_2d(aes(fill = after_stat(level)), geom = "polygon", bins = .bins) +
        xlab("MsQuality") + 
        ylab("QuaMeter") +
        coord_fixed(ratio = 1) +
        theme_classic() +
        theme(legend.position = "none")

## rtOverMsQuarters vs RT_MSMS_Q3
gg_rt_msQuarters_q3_msLevel2 <- .metrics_sps_msLevel2 |>
    filter(!is.na(Curated_Quality)) |>
    mutate(RT_MSMS_Q3 = RT_MSMS_Q1 + RT_MSMS_Q2 + RT_MSMS_Q3) |>
    ggplot(aes(x = `rtOverMsQuarters.Quarter3`, y = RT_MSMS_Q3)) +
        stat_density_2d(aes(fill = after_stat(level)), geom = "polygon", bins = .bins) +
        xlab("MsQuality") + 
        ylab("QuaMeter") +
        coord_fixed(ratio = 1) +
        theme_classic() +
        theme(legend.position = "none")

row1 <- ggarrange(
    annotate_figure(ggarrange(gg_rt_msQuarters_q1_msLevel1, labels = "a"), 
        top = "Q1"),
    annotate_figure(ggarrange(gg_rt_msQuarters_q2_msLevel1, labels = "b"), 
        top = "Q2"),
    annotate_figure(ggarrange(gg_rt_msQuarters_q3_msLevel1, labels = "c"), 
        top = "Q3"),
    ncol = 3, nrow = 1) |>
    annotate_figure(left = "MS1")
row2 <- ggarrange(
    annotate_figure(ggarrange(gg_rt_msQuarters_q1_msLevel2, labels = "d")), 
    annotate_figure(ggarrange(gg_rt_msQuarters_q2_msLevel2, labels = "e")),
    annotate_figure(ggarrange(gg_rt_msQuarters_q3_msLevel2, labels = "f")),
    ncol = 3, nrow = 1) |>
    annotate_figure(left = "MS2")
p <- ggarrange(row1, row2, ncol = 1, nrow = 2)

annotate_figure(p, top = text_grob("RT over MS Quarters"))

## calculate correlation
cor_rt_msQuarters_q1_msLevel1_p <- cor.test(
    .metrics_sps_msLevel1[["rtOverMsQuarters.Quarter1"]],
    .metrics_sps_msLevel1[["RT_MS_Q1"]], method = "pearson")
cor_rt_msQuarters_q1_msLevel1_s <- cor.test(
    .metrics_sps_msLevel1[["rtOverMsQuarters.Quarter1"]],
    .metrics_sps_msLevel1[["RT_MS_Q1"]], method = "spearman")
cor_rt_msQuarters_q1_msLevel2_p <- cor.test(
    .metrics_sps_msLevel2[["rtOverMsQuarters.Quarter1"]],
    .metrics_sps_msLevel2[["RT_MSMS_Q1"]], method = "pearson")
cor_rt_msQuarters_q1_msLevel2_s <- cor.test(
    .metrics_sps_msLevel2[["rtOverMsQuarters.Quarter1"]], 
    .metrics_sps_msLevel2[["RT_MSMS_Q1"]], method = "spearman")

tmp <- .metrics_sps_msLevel1[["RT_MS_Q1"]] +
    .metrics_sps_msLevel1[["RT_MS_Q2"]]
cor_rt_msQuarters_q2_msLevel1_p <- cor.test(
    .metrics_sps_msLevel1[["rtOverMsQuarters.Quarter2"]], tmp, method = "pearson")
cor_rt_msQuarters_q2_msLevel1_s <- cor.test(
    .metrics_sps_msLevel1[["rtOverMsQuarters.Quarter2"]], tmp, method = "spearman")
tmp <- .metrics_sps_msLevel1[["RT_MSMS_Q1"]] +
    .metrics_sps_msLevel1[["RT_MSMS_Q2"]]
cor_rt_msQuarters_q2_msLevel2_p <- cor.test(
    .metrics_sps_msLevel2[["rtOverMsQuarters.Quarter2"]], tmp, method = "pearson")
cor_rt_msQuarters_q2_msLevel2_s <- cor.test(
    .metrics_sps_msLevel2[["rtOverMsQuarters.Quarter2"]], tmp, method = "spearman")

tmp <- .metrics_sps_msLevel1[["RT_MS_Q1"]] +
    .metrics_sps_msLevel1[["RT_MS_Q2"]] +
    .metrics_sps_msLevel1[["RT_MS_Q3"]]
cor_rt_msQuarters_q3_msLevel1_p <- cor.test(
    .metrics_sps_msLevel1[["rtOverMsQuarters.Quarter3"]], tmp, method = "pearson")
cor_rt_msQuarters_q3_msLevel1_s <- cor.test(
    .metrics_sps_msLevel1[["rtOverMsQuarters.Quarter3"]], tmp, method = "spearman")
tmp <- .metrics_sps_msLevel1[["RT_MSMS_Q1"]] +
    .metrics_sps_msLevel1[["RT_MSMS_Q2"]] +
    .metrics_sps_msLevel1[["RT_MSMS_Q3"]]
cor_rt_msQuarters_q3_msLevel2_p <- cor.test(
    .metrics_sps_msLevel2[["rtOverMsQuarters.Quarter3"]], tmp, method = "pearson")
cor_rt_msQuarters_q3_msLevel2_s <- cor.test(
    .metrics_sps_msLevel2[["rtOverMsQuarters.Quarter3"]], tmp, method = "spearman")
```

```{r msSignal10xChangeComparison-amidan2014, fig.cap = "Comparison of quality metrics calculated by `MsQuality` and `QuaMeter`: MS Signal >10x Change (jump, `msSignal10xChange`). The metrics are only calculated from MS1 spectra. One data point is obtained per MS1 spectra and the data points are displayed on the x- and y-axis.", warning = FALSE, echo = FALSE}

.bins <- 20
##
## msSignal10xChange vs. IS-1A (jumps)
p <- .metrics_sps_msLevel1 |>
    filter(!is.na(Curated_Quality)) |>
    mutate(IS_1A = as.numeric(IS_1A)) |>
    ggplot(aes(x = msSignal10xChange, y = IS_1A)) +
        geom_point(alpha = 0.2) +
        xlab("MsQuality") + 
        ylab("QuaMeter") +
        theme_classic() +
        xlim(0, 1500) + ylim(0, 1500) +
        guides(colour = guide_legend(override.aes = list(alpha = 1)))

annotate_figure(p, top = text_grob("MS Signal >10x Change (jump)"))

## calculate correlation
cor_msSignal10xChange_msLevel1_p <- cor.test(
    .metrics_sps_msLevel1[["msSignal10xChange"]],
    as.numeric(.metrics_sps_msLevel1[["IS_1A"]]), method = "pearson")
cor_msSignal10xChange_msLevel1_s <- cor.test(
    .metrics_sps_msLevel1[["msSignal10xChange"]],
    as.numeric(.metrics_sps_msLevel1[["IS_1A"]]), method = "spearman")
```

The Figures \@ref(fig:rtDurationComparison-amidan2014),
\@ref(fig:numberSpectraComparison-amidan2014),
\@ref(fig:rtOverTicQuantilesComparison-amidan2014), 
\@ref(fig:rtOverMsQuartersComparison-amidan2014),
\@ref(fig:msSignal10xChangeComparison-amidan2014) 
indicate that the `QuaMeter` and `MsQuality` generally compute
similar values. This is shown by values that show high correlation (points
locate close to the identity line within the scatter plots). We provide in 
Table \@ref(tab:correlation) the Pearson and Spearman correlation coefficients
of the `MsQuality` metrics with their corresponding `QuaMeter` metrics.

```{r eval = TRUE, echo = FALSE}
.cols <- c("MsQuality", "QuaMeter", "MS level", "Pearson coef.", "Spearman coef.")

df <- data.frame(rbind(
    c("rtDuration", "RT_Duration", 1, 
        round(cor_rtDuration_p$estimate, 3),
        round(cor_rtDuration_s$estimate, 3)), 
    c("numberSpectra", "MS1_Count", 1, 
        round(cor_numberSpectra_msLevel1_p$estimate, 3), 
        round(cor_numberSpectra_msLevel1_s$estimate, 3)),
    c("numberSpectra", "MS2_Count", 2,
        round(cor_numberSpectra_msLevel2_p$estimate, 3), 
        round(cor_numberSpectra_msLevel2_s$estimate, 3)),
    c("rtOverTicQuantiles.25%", "RT_TIC_Q1", 1, 
        round(cor_rt_tic_q1_msLevel1_p$estimate, 3),
        round(cor_rt_tic_q1_msLevel1_s$estimate, 3)),
    c("rtOverTicQuantiles.25%", "RT_TIC_Q1", 2, 
        round(cor_rt_tic_q1_msLevel2_p$estimate, 3),
        round(cor_rt_tic_q1_msLevel2_s$estimate, 3)),
    c("rtOverTicQuantiles.50%", "RT_TIC_Q2", 1, 
        round(cor_rt_tic_q2_msLevel1_p$estimate, 3),
        round(cor_rt_tic_q2_msLevel1_s$estimate, 3)),
    c("rtOverTicQuantiles.50%", "RT_TIC_Q2", 2, 
        round(cor_rt_tic_q2_msLevel2_p$estimate, 3),
        round(cor_rt_tic_q2_msLevel2_s$estimate, 3)),
    c("rtOverTicQuantiles.75%", "RT_TIC_Q3", 1, 
        round(cor_rt_tic_q3_msLevel1_p$estimate, 3),
        round(cor_rt_tic_q3_msLevel1_s$estimate, 3)),
    c("rtOverTicQuantiles.75%", "RT_TIC_Q3", 2, 
        round(cor_rt_tic_q3_msLevel2_p$estimate, 3),
        round(cor_rt_tic_q3_msLevel2_s$estimate, 3)),
    c("rtOverMsQuarters.Quarter1", "RT_MS_Q1", 1, 
        round(cor_rt_msQuarters_q1_msLevel1_p$estimate, 3),
        round(cor_rt_msQuarters_q1_msLevel1_s$estimate, 3)),
    c("rtOverMsQuarters.Quarter1", "RT_MSMS_Q1", 2, 
        round(cor_rt_msQuarters_q1_msLevel2_p$estimate, 3), 
        round(cor_rt_msQuarters_q1_msLevel2_s$estimate, 3)),
    c("rtOverMsQuarters.Quarter2", "RT_MS_Q2", 1, 
        round(cor_rt_msQuarters_q2_msLevel1_p$estimate, 3),
        round(cor_rt_msQuarters_q2_msLevel1_s$estimate, 3)),
    c("rtOverMsQuarters.Quarter2", "RT_MSMS_Q2", 2,
        round(cor_rt_msQuarters_q2_msLevel2_p$estimate, 3),
        round(cor_rt_msQuarters_q2_msLevel2_s$estimate, 3)),
    c("rtOverMsQuarters.Quarter3", "RT_MS_Q3", 1, 
        round(cor_rt_msQuarters_q3_msLevel1_p$estimate, 3),
        round(cor_rt_msQuarters_q3_msLevel1_s$estimate, 3)),
    c("rtOverMsQuarters.Quarter3", "RT_MSMS_Q3", 2,
        round(cor_rt_msQuarters_q3_msLevel2_p$estimate, 3),
        round(cor_rt_msQuarters_q3_msLevel2_s$estimate, 3)),
    c("msSignal10xChange", "IS_1A", 1, 
        round(cor_msSignal10xChange_msLevel1_p$estimate, 3),
        round(cor_msSignal10xChange_msLevel1_s$estimate, 3))
))
colnames(df) <- .cols

## calculate some statistics on the correlation values
##quantile(as.numeric(df[, "Pearson coef."]))
##quantile(as.numeric(df[, "Spearman coef."]))


knitr::kable(df, caption = "Pearson and Spearman coefficients for \\texttt{MsQuality} and pre-calculated QuaMeter metrics. The correlation analysis showed that 75\\% of the metrics showed Pearson/Spearman correlation coefficients over 0.81/0.87, 50\\% over 0.89/0.91, and 25\\% over 0.96/0.98 between \\texttt{MsQuality} and QuaMeter metrics.", format = "latex", label= "correlation")
```

\newpage 

## Performance under parallelization

Similar to the above-mentioned analysis using the flow injection
analysis, an important aspect, especially when dealing with large amount of data, 
is scalability and performance when computing the quality metric. 

We measure the time it takes to calculate the quality 
metrics under parallelization of the tasks on 1, 2, 4, 8, and 16 workers 
using the `microbenchmark` package. For computational
reasons we limit the calculation to the first 500 .mzML files.

```{r df_mb_Amidan2014, echo = TRUE, eval = FALSE}
.path <- "/scratch/naake/Amidan2014"
fls <- dir(.path, full.names = TRUE, recursive = TRUE, pattern = "mzML") |>
    unique()
fls <- fls[1:500]
sps_mb <- sps[sps$dataOrigin %in% fls] 

.metrics <- c("rtDuration", "rtOverTicQuantiles", "rtOverMsQuarters", 
    "ticQuartileToQuartileLogRatio", "numberSpectra", 
    "medianPrecursorMz", "rtIqr", "rtIqrRate", "areaUnderTic", 
    "areaUnderTicRtQuantiles", "medianTicRtIqr", "medianTicOfRtRange",
    "mzAcquisitionRange", "rtAcquisitionRange", "precursorIntensityRange", 
    "precursorIntensityQuartiles", "precursorIntensityMean", 
    "precursorIntensitySd", "msSignal10xChange", "ratioCharge1over2", 
    "ratioCharge3over2", "ratioCharge4over2", "meanCharge", 
    "medianCharge")

df_mb <- microbenchmark(
    workers_1 = calculateMetricsFromSpectra(spectra = sps_mb, 
	    metrics = .metrics, BPPARAM = MulticoreParam(workers = 1)),
    workers_2 = calculateMetricsFromSpectra(spectra = sps_mb, 
		metrics = .metrics, BPPARAM = MulticoreParam(workers = 2)),
    workers_4 = calculateMetricsFromSpectra(spectra = sps_mb, 
		metrics = .metrics, BPPARAM = MulticoreParam(workers = 4)),
    workers_8 = calculateMetricsFromSpectra(spectra = sps_mb, 
		metrics = .metrics, BPPARAM = MulticoreParam(workers = 8)),
    workers_16 = calculateMetricsFromSpectra(spectra = sps_mb, 
		metrics = .metrics, BPPARAM = MulticoreParam(workers = 16)), 
	times = 32L, control = list(warmup = 2), check = "equal"
)
```

```{r df_mb_saveRDS_Amidan2014, eval = FALSE, echo = FALSE}
## save the data.frame
saveRDS(df_mb, file = "../Amidan2014/Amidan2014_df_mb.RDS")
```

```{r df_mb_readRDS_Amidan2014, eval = TRUE, echo = FALSE}
df_mb <- readRDS(file = "../Amidan2014/Amidan2014_df_mb.RDS")
```

```{r microbenchmark-amidan2014, echo = FALSE, eval = TRUE, fig.cap = "Execution time for the calculation of quality metrics of the data set of @Amidan2014 under parallelization (1, 2, 4, 8, and 16 workers).", warning=FALSE}
## convert from nano seconds to seconds
df_mb[["time"]] <- df_mb[["time"]] / 10e9
df_mb <- df_mb |>
    as.data.frame() |>
    mutate(expr = case_when(expr == "workers_1" ~ 1,
        expr == "workers_2" ~ 2, expr == "workers_4" ~ 4,
        expr == "workers_8" ~ 8, expr == "workers_16" ~ 16))

## visualize the elapsed time per amount of used workers
gg_mb <- ggplot(df_mb) +
    geom_jitter(aes(x = expr, y = time, col = as.factor(expr)), alpha = 0.2) +
    geom_violin(aes(x = expr, y = time, group = expr, fill = NA), fill = alpha("white", 0)) +
    xlab("number of workers") + ylab("elapsed time (s)") +
    scale_x_continuous(breaks = df_mb[["expr"]]) +
    guides(color = guide_legend(override.aes = list(alpha = 1))) +
    theme_classic() +
    theme(legend.position = "none")
gg_mb 
```

The `microbenchmark` package was used to accurately measure the performance 
improvements achieved by parallelization (Figure 
\@ref(fig:microbenchmark-amidan2014)). By parallelizing the calculation of 
the quality metrics across multiple workers, it is possible to significantly 
reduce the execution time.


```{r figure_main, echo = FALSE, message = FALSE, warning=FALSE, results = FALSE, fig.show = "hide"}
## combine several plots into one figure for the main part of the manuscript

## gg_tic_msLevel1: metric for classification into good and poor quality samples
## gg_tic75_msLevel1: metric for classification into good and poor quality 
## samples
## gg_rt_tic_msLevel1: comparison between QuaMeter/MsQuality metrics
## gg_mb: benchmark of computation using microbenchmark package
fig_a <- gg_tic_msLevel1 |>
    patchworkGrob() |>
    gridExtra::grid.arrange( 
        left = text_grob("area under TIC (A.U.)", size = 10, rot = 90), 
        bottom = text_grob("retention time (s, in 10e3)", size = 10, vjust = -0.4))
fig_b <- gg_tic75_msLevel1 |>
    patchworkGrob() |>
    gridExtra::grid.arrange( 
        left = text_grob("area under TIC RT \n quantile (75%)   ", 
            size = 10, rot = 90, just = c("center", "center")), 
        bottom = text_grob("retention time (s, in 10e3)", size = 10, vjust = -0.4))
fig_c <- gg_rt_tic_msLevel1 +
    xlab("RT over TIC quantiles  (MsQuality)  ") + 
    ylab("RT over TIC quantiles  (QuaMeter)  ") +
    theme(axis.title.x = element_text(size = 9),
        axis.title.y = element_text(size = 9),
        legend.text = element_text(size = 8))
fig_d <- gg_mb +
    theme(axis.title = element_text(size = 10))

pdf("/g/huber/users/naake/GitHub/MsQuality_manuscript/main/figure-main.pdf")
ggarrange( fig_a, fig_b, fig_c, fig_d, ncol = 2, nrow = 2, labels = "auto", 
          align = "h")
dev.off()
```

\newpage

# Session info \label{sec:Session Info}

Information on the attached packages.

```{r sessionInfo, echo = FALSE}
## remove BLAS, LAPACK, and not attached packages
ind_BLAS <- which(names(sessionInfo()) == "BLAS")
ind_LAPACK <- which(names(sessionInfo()) == "LAPACK")
ind_notattached <- which(names(sessionInfo()) == "loadedOnly")
inds_remove <- -c(ind_BLAS, ind_LAPACK, ind_notattached)
utils:::print.sessionInfo(sessionInfo()[inds_remove])
```

\newpage

# References

